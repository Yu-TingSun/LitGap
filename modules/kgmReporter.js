/**
 * LitGap - KGM Reporter Module
 * Generates Markdown and HTML reports for Knowledge Gap Mapping analysis
 *
 * @module kgmReporter
 * @version 2.0.0
 *
 * Public API:
 *   generate(collectionName, libraryData, missingPapers, framework, gapAnalysis, providerName)
 *     â†’ { markdown, html }
 *
 * Design notes:
 *   - Pure functions, no Zotero API calls, no async
 *   - HTML style matches existing reporter.js colour scheme
 *   - "Suggested question" blocks get special styling + Copy button
 *   - Markdown is rendered to HTML via a lightweight converter (no external lib)
 */

var KGMReporter = {

  // â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Generate both Markdown and HTML KGM reports.
   *
   * @param {string}   collectionName  - Zotero collection name
   * @param {{ allTitles: string[], topAbstracts: Array }} libraryData
   * @param {Array<{title:string, mentionCount:number}>}   missingPapers
   * @param {string}   framework       - Step A AI output (Markdown)
   * @param {string}   gapAnalysis     - Step B AI output (Markdown)
   * @param {string}   providerName    - Display name e.g. "Anthropic Claude"
   * @returns {{ markdown: string, html: string }}
   */
  generate: function(collectionName, libraryData, missingPapers, framework, gapAnalysis, providerName) {
    Zotero.debug('KGMReporter: Generating reports...');

    const dateStr  = new Date().toISOString().split('T')[0];
    const provider = providerName || 'AI Assistant';

    const markdown = this._buildMarkdown(
      collectionName, libraryData, missingPapers,
      framework, gapAnalysis, provider, dateStr
    );

    const html = this._buildHTML(
      collectionName, libraryData, missingPapers,
      framework, gapAnalysis, provider, dateStr
    );

    Zotero.debug(`KGMReporter: Markdown ${markdown.length} chars, HTML ${html.length} chars`);
    return { markdown, html };
  },

  // â”€â”€â”€ Markdown builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * @private
   */
  _buildMarkdown: function(collectionName, libraryData, missingPapers, framework, gapAnalysis, provider, dateStr) {
    const lines = [];

    lines.push(`# Knowledge Gap Map: ${collectionName}`);
    lines.push('');
    lines.push(`**Generated:** ${dateStr} | **Powered by:** KGM + ${provider}`);
    lines.push('');
    lines.push('---');
    lines.push('');

    // Research context
    lines.push('## Your Research Context');
    lines.push('');
    lines.push(`- **Collection:** ${collectionName}`);
    lines.push(`- **Papers analyzed:** ${libraryData.allTitles.length} titles`);
    lines.push(`- **Missing papers from LitGap:** ${missingPapers.length} papers`);
    lines.push('');
    lines.push('---');
    lines.push('');

    // Step A output
    lines.push(framework.trim());
    lines.push('');
    lines.push('---');
    lines.push('');

    // Step B output
    lines.push(gapAnalysis.trim());
    lines.push('');
    lines.push('---');
    lines.push('');

    // How to use
    lines.push('## How to Use This Report');
    lines.push('');
    lines.push('1. Read the **Domain Knowledge Framework** to understand how your field is organized');
    lines.push('2. Review each **Conceptual Gap** â€” pay attention to what you might not know');
    lines.push('3. Copy the **"Suggested question"** blocks directly into Claude, ChatGPT, or any AI assistant');
    lines.push('4. Use the listed paper titles to search in Google Scholar or Semantic Scholar');
    lines.push('5. Re-run this analysis after reading new papers for updated gap detection');
    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push(`*Generated by LitGap v2.0 KGM on ${dateStr}*`);

    return lines.join('\n');
  },

  // â”€â”€â”€ HTML builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * @private
   */
  _buildHTML: function(collectionName, libraryData, missingPapers, framework, gapAnalysis, provider, dateStr) {
    const lines = [];

    lines.push('<!DOCTYPE html>');
    lines.push('<html lang="en">');
    lines.push('<head>');
    lines.push('  <meta charset="UTF-8">');
    lines.push('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
    lines.push(`  <title>KGM Report: ${this._esc(collectionName)}</title>`);
    lines.push('  <style>');
    lines.push(this._getStyles());
    lines.push('  </style>');
    lines.push('</head>');
    lines.push('<body>');
    lines.push('<div class="container">');

    // Header
    lines.push('<header>');
    lines.push(`  <h1>ğŸ—ºï¸ Knowledge Gap Map</h1>`);
    lines.push(`  <p class="collection-name">${this._esc(collectionName)}</p>`);
    lines.push(`  <p class="date">Generated: ${dateStr} &nbsp;|&nbsp; Powered by: KGM + ${this._esc(provider)}</p>`);
    lines.push('</header>');

    // Research context
    lines.push('<section class="context-section">');
    lines.push('  <h2>ğŸ“š Your Research Context</h2>');
    lines.push('  <ul class="context-list">');
    lines.push(`    <li><strong>Collection:</strong> ${this._esc(collectionName)}</li>`);
    lines.push(`    <li><strong>Papers analyzed:</strong> ${libraryData.allTitles.length} titles</li>`);
    lines.push(`    <li><strong>Missing papers from LitGap:</strong> ${missingPapers.length} papers</li>`);
    lines.push('  </ul>');
    lines.push('</section>');

    // Framework section (Step A)
    lines.push('<section class="framework-section">');
    lines.push(this._markdownToHTML(framework.trim()));
    lines.push('</section>');

    // Gap analysis section (Step B) â€” special rendering for "Suggested question"
    lines.push('<section class="gap-section">');
    lines.push(this._renderGapAnalysis(gapAnalysis.trim()));
    lines.push('</section>');

    // How to use
    lines.push('<section class="howto-section">');
    lines.push('  <h2>ğŸ’¡ How to Use This Report</h2>');
    lines.push('  <ol>');
    lines.push('    <li>Read the <strong>Domain Knowledge Framework</strong> to understand how your field is organized</li>');
    lines.push('    <li>Review each <strong>Conceptual Gap</strong> â€” pay attention to what you might not know</li>');
    lines.push('    <li>Copy the <strong>"Suggested question"</strong> blocks directly into Claude, ChatGPT, or any AI assistant</li>');
    lines.push('    <li>Use the listed paper titles to search in Google Scholar or Semantic Scholar</li>');
    lines.push('    <li>Re-run this analysis after reading new papers for updated gap detection</li>');
    lines.push('  </ol>');
    lines.push('</section>');

    // Footer
    lines.push('<footer>');
    lines.push(`  <p>Generated by <strong>LitGap v2.0 KGM</strong> on ${dateStr}</p>`);
    lines.push('</footer>');

    lines.push('</div>'); // .container

    // Copy button script
    lines.push('<script>');
    lines.push(this._getCopyScript());
    lines.push('</script>');

    lines.push('</body>');
    lines.push('</html>');

    return lines.join('\n');
  },

  // â”€â”€â”€ Markdown â†’ HTML converter (lightweight, no external lib) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * Convert a Markdown string to HTML.
   * Handles: h2, h3, h4, bold, bullet lists, paragraphs.
   *
   * @private
   * @param {string} md
   * @returns {string} HTML string
   */
  _markdownToHTML: function(md) {
    const lines  = md.split('\n');
    const html   = [];
    let inList   = false;
    let inPara   = false;

    const closeList  = () => { if (inList)  { html.push('</ul>'); inList  = false; } };
    const closePara  = () => { if (inPara)  { html.push('</p>');  inPara  = false; } };

    for (let i = 0; i < lines.length; i++) {
      const raw  = lines[i];
      const line = raw.trimEnd();

      // Headings
      if (line.startsWith('#### ')) {
        closeList(); closePara();
        html.push(`<h4>${this._inlineFormat(line.slice(5))}</h4>`);
        continue;
      }
      if (line.startsWith('### ')) {
        closeList(); closePara();
        html.push(`<h3>${this._inlineFormat(line.slice(4))}</h3>`);
        continue;
      }
      if (line.startsWith('## ')) {
        closeList(); closePara();
        html.push(`<h2>${this._inlineFormat(line.slice(3))}</h2>`);
        continue;
      }
      if (line.startsWith('# ')) {
        closeList(); closePara();
        html.push(`<h1>${this._inlineFormat(line.slice(2))}</h1>`);
        continue;
      }

      // Horizontal rule
      if (/^---+$/.test(line.trim())) {
        closeList(); closePara();
        html.push('<hr>');
        continue;
      }

      // Bullet list item
      if (/^[-*]\s+/.test(line)) {
        closePara();
        if (!inList) { html.push('<ul>'); inList = true; }
        const content = line.replace(/^[-*]\s+/, '');
        html.push(`  <li>${this._inlineFormat(content)}</li>`);
        continue;
      }

      // Numbered list item
      if (/^\d+\.\s+/.test(line)) {
        closePara();
        if (!inList) { html.push('<ol>'); inList = true; }
        const content = line.replace(/^\d+\.\s+/, '');
        html.push(`  <li>${this._inlineFormat(content)}</li>`);
        continue;
      }

      // Empty line
      if (line.trim() === '') {
        closeList(); closePara();
        continue;
      }

      // Regular paragraph text
      closeList();
      if (!inPara) { html.push('<p>'); inPara = true; }
      else { html.push('<br>'); }
      html.push(this._inlineFormat(line));
    }

    closeList(); closePara();
    return html.join('\n');
  },

  /**
   * Render the gap analysis section with special "Suggested question" styling.
   * Detects the "Suggested question for your AI assistant:" bold label and
   * wraps the following text in a styled card with a Copy button.
   *
   * @private
   * @param {string} md - Gap analysis Markdown
   * @returns {string} HTML
   */
  _renderGapAnalysis: function(md) {
    // Split into lines and process
    const lines  = md.split('\n');
    const html   = [];
    let inSuggestedBlock = false;
    let suggestedLines   = [];
    let inList   = false;
    let inPara   = false;

    const closeList = () => { if (inList)  { html.push('</ul>'); inList  = false; } };
    const closePara = () => { if (inPara)  { html.push('</p>');  inPara  = false; } };

    const flushSuggested = () => {
      if (!inSuggestedBlock) return;
      const text = suggestedLines.join('\n').trim();
      const id   = 'sq-' + Math.random().toString(36).slice(2, 8);
      html.push('<div class="suggested-question">');
      html.push('  <div class="sq-header">');
      html.push('    <span class="sq-label">ğŸ’¬ Suggested question for your AI assistant</span>');
      html.push(`    <button class="copy-btn" onclick="copyText('${id}')">ğŸ“‹ Copy</button>`);
      html.push('  </div>');
      html.push(`  <div class="sq-content" id="${id}">${this._esc(text)}</div>`);
      html.push('</div>');
      inSuggestedBlock = false;
      suggestedLines   = [];
    };

    for (let i = 0; i < lines.length; i++) {
      const raw  = lines[i];
      const line = raw.trimEnd();

      // Detect start of "Suggested question" block
      // Matches: **Suggested question for your AI assistant:**
      if (/\*\*Suggested question[^*]*\*\*/.test(line)) {
        closeList(); closePara(); flushSuggested();
        inSuggestedBlock = true;
        // Check if the question text is on the same line after the label
        const afterLabel = line.replace(/\*\*Suggested question[^*]*\*\*:?\s*/i, '').trim();
        if (afterLabel) suggestedLines.push(afterLabel);
        continue;
      }

      // While inside suggested block, collect lines until next heading or empty line
      // followed by a heading/bold label (i.e., next section starts)
      if (inSuggestedBlock) {
        const nextLine = lines[i + 1] || '';
        const isNextSection = /^(#{1,4}\s|\*\*[A-Z])/.test(nextLine.trim());

        if (line.trim() === '' && isNextSection) {
          flushSuggested();
          continue;
        }
        if (/^#{1,4}\s/.test(line)) {
          flushSuggested();
          // Fall through to heading handling below
        } else {
          suggestedLines.push(line);
          continue;
        }
      }

      // Standard Markdown processing (same as _markdownToHTML)
      if (line.startsWith('#### ')) {
        closeList(); closePara();
        html.push(`<h4>${this._inlineFormat(line.slice(5))}</h4>`);
        continue;
      }
      if (line.startsWith('### ')) {
        closeList(); closePara();
        html.push(`<h3>${this._inlineFormat(line.slice(4))}</h3>`);
        continue;
      }
      if (line.startsWith('## ')) {
        closeList(); closePara();
        html.push(`<h2>${this._inlineFormat(line.slice(3))}</h2>`);
        continue;
      }
      if (/^---+$/.test(line.trim())) {
        closeList(); closePara();
        html.push('<hr>');
        continue;
      }
      if (/^[-*]\s+/.test(line)) {
        closePara();
        if (!inList) { html.push('<ul>'); inList = true; }
        html.push(`  <li>${this._inlineFormat(line.replace(/^[-*]\s+/, ''))}</li>`);
        continue;
      }
      if (/^\d+\.\s+/.test(line)) {
        closePara();
        if (!inList) { html.push('<ol>'); inList = true; }
        html.push(`  <li>${this._inlineFormat(line.replace(/^\d+\.\s+/, ''))}</li>`);
        continue;
      }
      if (line.trim() === '') {
        closeList(); closePara();
        continue;
      }
      closeList();
      if (!inPara) { html.push('<p>'); inPara = true; }
      else { html.push('<br>'); }
      html.push(this._inlineFormat(line));
    }

    closeList(); closePara(); flushSuggested();
    return html.join('\n');
  },

  /**
   * Apply inline Markdown formatting: **bold**, *italic*, `code`.
   *
   * @private
   */
  _inlineFormat: function(text) {
    if (!text) return '';
    return this._esc(text)
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g,     '<em>$1</em>')
      .replace(/`(.+?)`/g,       '<code>$1</code>');
  },

  /**
   * Escape HTML special characters.
   * @private
   */
  _esc: function(text) {
    if (!text) return '';
    return String(text)
      .replace(/&/g,  '&amp;')
      .replace(/</g,  '&lt;')
      .replace(/>/g,  '&gt;')
      .replace(/"/g,  '&quot;')
      .replace(/'/g,  '&#039;');
  },

  // â”€â”€â”€ Copy button script â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * @private
   */
  _getCopyScript: function() {
    return `
function copyText(id) {
  var el = document.getElementById(id);
  if (!el) return;
  var text = el.innerText || el.textContent;
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(text).then(function() {
      var btn = el.parentElement.querySelector('.copy-btn');
      if (btn) { btn.textContent = 'âœ“ Copied!'; setTimeout(function(){ btn.textContent = 'ğŸ“‹ Copy'; }, 2000); }
    });
  } else {
    var ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.opacity  = '0';
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    var btn = el.parentElement.querySelector('.copy-btn');
    if (btn) { btn.textContent = 'âœ“ Copied!'; setTimeout(function(){ btn.textContent = 'ğŸ“‹ Copy'; }, 2000); }
  }
}`;
  },

  // â”€â”€â”€ CSS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  /**
   * @private
   */
  _getStyles: function() {
    return `
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  line-height: 1.7;
  color: #24292e;
  background: #f6f8fa;
  padding: 20px;
}

.container {
  max-width: 900px;
  margin: 0 auto;
  background: white;
  padding: 40px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* Header */
header {
  text-align: center;
  margin-bottom: 36px;
  padding-bottom: 20px;
  border-bottom: 2px solid #e1e4e8;
}
header h1  { font-size: 2.2em; color: #24292e; margin-bottom: 8px; }
.collection-name { font-size: 1.2em; color: #0366d6; font-weight: 600; margin-bottom: 4px; }
.date { color: #586069; font-size: 0.9em; }

/* Section spacing */
section { margin-bottom: 40px; }

/* Headings */
h2 {
  font-size: 1.6em; color: #24292e;
  margin: 28px 0 16px;
  padding-bottom: 8px;
  border-bottom: 1px solid #e1e4e8;
}
h3 { font-size: 1.25em; color: #0366d6; margin: 22px 0 10px; }
h4 { font-size: 1.05em; color: #24292e; margin: 16px 0 8px; }
p  { margin: 8px 0; }
hr { border: none; border-top: 1px solid #e1e4e8; margin: 24px 0; }

/* Lists */
ul, ol { padding-left: 28px; margin: 8px 0; }
li { margin: 4px 0; }
code { background: #f6f8fa; padding: 2px 5px; border-radius: 3px; font-size: 0.9em; }

/* Context list */
.context-list { list-style: none; padding: 0; }
.context-list li { padding: 6px 0; border-bottom: 1px solid #f6f8fa; }

/* Framework section */
.framework-section {
  background: #f8fbff;
  border-left: 4px solid #0366d6;
  padding: 20px 24px;
  border-radius: 4px;
}

/* Gap section */
.gap-section { }

/* Suggested question card */
.suggested-question {
  background: #EBF5FB;
  border-left: 4px solid #0366d6;
  border-radius: 6px;
  padding: 16px 20px;
  margin: 16px 0;
}
.sq-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}
.sq-label {
  font-weight: 600;
  color: #0366d6;
  font-size: 0.95em;
}
.copy-btn {
  background: #0366d6;
  color: white;
  border: none;
  padding: 5px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s;
  white-space: nowrap;
}
.copy-btn:hover { background: #0256c7; }
.sq-content {
  color: #24292e;
  font-size: 0.95em;
  line-height: 1.6;
  white-space: pre-wrap;
  word-break: break-word;
}

/* How to use */
.howto-section {
  background: #f6fff6;
  border-left: 4px solid #28a745;
  padding: 20px 24px;
  border-radius: 4px;
}
.howto-section ol { padding-left: 22px; }
.howto-section li { margin: 8px 0; }

/* Footer */
footer {
  text-align: center;
  margin-top: 40px;
  padding-top: 16px;
  border-top: 1px solid #e1e4e8;
  color: #586069;
  font-size: 0.9em;
}

/* Print */
@media print {
  body { background: white; padding: 0; }
  .container { box-shadow: none; max-width: 100%; }
  .copy-btn { display: none; }
}

/* Mobile */
@media (max-width: 768px) {
  body { padding: 10px; }
  .container { padding: 20px; }
  header h1 { font-size: 1.7em; }
  .sq-header { flex-direction: column; align-items: flex-start; gap: 8px; }
}`;
  }
};
